package com.captainslog.qr

import android.util.Base64
import com.google.gson.Gson
import com.google.gson.JsonElement
import com.google.gson.annotations.SerializedName
import java.io.ByteArrayInputStream
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.zip.GZIPInputStream

/**
 * QR Code Data Protocol for Captain's Log
 *
 * Handles decoding and validation of QR payloads generated by the web interface.
 * Supports multi-QR chunking for large datasets (trips/boats with photos).
 */
object QrProtocol {
    const val CURRENT_VERSION = 1
    const val MIN_SUPPORTED_VERSION = 1
    const val MAX_SUPPORTED_VERSION = 1
    const val AGE_WARNING_MONTHS = 6L

    /**
     * QR envelope structure - matches web QR generator output
     */
    data class QrEnvelope(
        @SerializedName("v") val version: Int,
        @SerializedName("type") val type: String,  // "trip" or "boat"
        @SerializedName("part") val part: Int,
        @SerializedName("total") val total: Int,
        @SerializedName("id") val id: String,
        @SerializedName("generatedAt") val generatedAt: String,
        @SerializedName("data") val data: String  // gzipped + base64 JSON fragment
    )

    /**
     * Result of decoding a complete QR payload (after multi-QR assembly)
     */
    sealed class QrDecodeResult {
        data class Success(
            val type: String,
            val data: JsonElement,
            val id: String,
            val generatedAt: String
        ) : QrDecodeResult()

        data class VersionTooOld(val version: Int) : QrDecodeResult()
        data class VersionTooNew(val version: Int) : QrDecodeResult()
        data class InvalidFormat(val message: String) : QrDecodeResult()
    }

    private val gson = Gson()

    /**
     * Parse a single QR code scan into an envelope
     * @param json Raw JSON string from QR code
     * @return Parsed envelope or null if invalid
     */
    fun parseEnvelope(json: String): QrEnvelope? {
        return try {
            gson.fromJson(json, QrEnvelope::class.java)
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Validate QR protocol version
     * @param version Version from QR envelope
     * @return Error result if version unsupported, null if OK
     */
    fun validateVersion(version: Int): QrDecodeResult? {
        return when {
            version < MIN_SUPPORTED_VERSION -> QrDecodeResult.VersionTooOld(version)
            version > MAX_SUPPORTED_VERSION -> QrDecodeResult.VersionTooNew(version)
            else -> null
        }
    }

    /**
     * Check if QR code is expired (older than AGE_WARNING_MONTHS)
     * @param generatedAt ISO 8601 timestamp from QR envelope
     * @return True if expired, false otherwise
     */
    fun isExpired(generatedAt: String): Boolean {
        return try {
            val generated = Instant.parse(generatedAt)
            val ageMonths = ChronoUnit.MONTHS.between(generated, Instant.now())
            ageMonths >= AGE_WARNING_MONTHS
        } catch (e: Exception) {
            false  // If we can't parse the date, assume not expired
        }
    }

    /**
     * Decode gzipped + base64 data fragment
     * @param base64GzipData Base64-encoded gzipped JSON fragment
     * @return Decompressed JSON string
     * @throws Exception if decompression fails
     */
    fun decodeData(base64GzipData: String): String {
        // Decode base64
        val compressedBytes = Base64.decode(base64GzipData, Base64.DEFAULT)

        // Decompress gzip
        val inputStream = GZIPInputStream(ByteArrayInputStream(compressedBytes))
        return inputStream.bufferedReader().use { it.readText() }
    }

    /**
     * Decode a complete QR payload (after all parts assembled)
     * @param fullBase64Data Concatenated base64+gzip data from all parts
     * @param type QR type ("trip" or "boat")
     * @param id QR envelope ID
     * @param generatedAt ISO timestamp
     * @param version Protocol version
     * @return Decode result with parsed JSON or error
     */
    fun decodeComplete(
        fullBase64Data: String,
        type: String,
        id: String,
        generatedAt: String,
        version: Int
    ): QrDecodeResult {
        // Validate version
        validateVersion(version)?.let { return it }

        return try {
            // Decompress and parse JSON
            val jsonString = decodeData(fullBase64Data)
            val jsonElement = gson.fromJson(jsonString, JsonElement::class.java)

            QrDecodeResult.Success(
                type = type,
                data = jsonElement,
                id = id,
                generatedAt = generatedAt
            )
        } catch (e: Exception) {
            QrDecodeResult.InvalidFormat("Failed to decode data: ${e.message}")
        }
    }
}
